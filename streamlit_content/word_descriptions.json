{
  "up": ["The slope estimation of a linear adjustment ($y= ax + b$) to the __subsequence__, being up $= a$, if $a$>0 or **up** $= 0$, if $a$<=0 \n ### Example:\n", "s1: up","figures\\thumbnail_up_down\\thumbnail_up_down-1.png"],
  "down": ["The slope estimation of a linear adjustment ($y= ax + b$) to the __subsequence__, being down $= a$, if $a$<0 or **down** $=0$, if $a$>=0 \n ### Example:\n","s1: down","figures\\thumbnail_up_down\\thumbnail_up_down-1.png"],
  "flat": ["The inverse of the sum of absolute differences between the __subsequence__ and its average: !flat(i) $= \\Sigma_{j=a}^{a+w} |t(j) - \\overline{t(a,a+w)}|$ \n ### Example:\n","s1: flat","figures\\thumbnail_flat\\thumbnail_flat-1.png"],
  "noise": ["The residual error when modeled by a moving average ($ma$). __noise(i)__ $=  \\Sigma_{j=a}^{a+w} |t_j - ma_j|$. \n ### Example:\n","s1: noise","figures\\thumbnail_noise\\thumbnail_noise-1.png"],
  "complex": ["The complexity-invariant distance measure of the __subsequence__, it computes the sum of the $n^{th}$ discrete differences of the subsequence: __complex(i)__ $= \\sqrt{\\Sigma^{n-1}_{i=1} (q_i - q_{i+1})^2}$ \n ### Example:\n", "s1: complex","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "simple": ["The inverse of the complexity-invariant distance measure of the __subsequence__: __simple__ $= 1-__complex__", "s1: simple","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "top": ["The moving average of the time series: $ma(i) = \\frac{1}{w}\\Sigma_{j=a}^{a+w} t(j)$.", "s1: top", "figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "bottom": ["The negation of **top**", "s1: bottom","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "valley": ["The logarithmic normalized euclidean distance to the template of a valley, modulated by a gaussian function.", "s1: valley","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "uval": ["The logarithmic normalized euclidean distance to the template of a U-shaped valley, modulated by a gaussian function.", "s1: valley","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "vval": ["The logarithmic normalized euclidean distance to the template of a V-shaped valley, modulated by a gaussian function.", "s1: valley","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "peak": ["The logarithmic normalized euclidean distance to the template of a peak, modulated by a gaussian function.","s1: peak", "figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "plateau_up": ["The logarithmic normalized euclidean distance to the template of a positive plateau, modulated by a square function.", "s1: plateau_up","s1: positive plateau","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "plateau_down": ["The logarithmic normalized euclidean distance to the template of a negative plateau, modulated by a square function.", "s1: plateau_down","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "step_up": ["The logarithmic normalized euclidean distance to the template of a positive step, modulated by a square function.", "s1: plateau_up","s1: positive plateau","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "step_down": ["The logarithmic normalized euclidean distance to the template of a negative step, modulated by a square function.", "s1: plateau_down","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "high": ["The difference between the maximum and minimum value of a __subsequence__: __high(i)__ $= max(t(a,a+w)) - min(t(a,a+w))$.", "s1: high","figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "low": ["The negation of **high**", "s1: low", "figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "symmetric": ["The normalized euclidean distance to the __subsequence__â€™s horizontally flipped self.", "s1: symmetric", "figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "assymmetric": ["The negation of **symmetric**.", "s1: asymmetric", "figures\\thumbnail_complex\\thumbnail_complex-1.png"],
  "not (!)": ["__Negation__ operator. Inversion of the word feature vector weights:\n $!word = 1-word$","s1: !up"],
  "followed by": ["Writting (word_A __followed by__ word_B) applies a time dependency on the resulting scores. It maximizes subsequences with high A that have a B on the next subsequence. It needs the round brackets to delimit the conditions for A and B. It also words between different signals.", "s1: (valley followed by up)"],
  "grouped followed by ([])": ["You can also describe your pattern as a sequence of time ordered properties. Use the square brackets to describe your subsequence.\n For example, [up down] says that the subsequence is up during the first half and down on the second half.","s1: [up down]"],
  "wildcard (.)": ["You might not be interested in describing the second half of a grouped followed by ([]). Use the wildcard to give the same weight to all scoring functions.","s1: [. valley]"]
}